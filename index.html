<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Journey - Task Tracker</title>
    
    <!-- PWA -->
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="32x32" href="logo.png">
<link rel="apple-touch-icon" href="logo.png">
<meta name="theme-color" content="#0f172a">
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Google Fonts for Cursive and Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Load Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <!-- React, ReactDOM, and Babel for in-browser JSX transpilation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* --- Theme-Independent Styles --- */
        body { 
            font-family: 'Inter', sans-serif; 
            transition: background-color 0.0s, color 0.0s;
        }
        .cursive-title {
            font-family: 'Great Vibes', cursive;
        }

        /* Hide scrollbar for aesthetics */
        body::-webkit-scrollbar { display: none; }
        body { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Transitions */
        .sidebar, .modal-card { transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; }
        .modal { transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out; }
        .progress-bar { transition: width 0.5s ease-out; }
        
        /* --- DYNAMIC THEME STYLES (via CSS Variables) --- */

        /* Base App Styles */
        .app-bg { background-color: var(--app-bg); }
        .app-text { color: var(--app-text); }
        .app-border { border-color: var(--app-border); }
        
        /* Primary/Accent Styles */
        .theme-text { color: var(--app-primary); }
        .theme-bg { background-color: var(--app-primary); }
        .theme-border { border-color: var(--app-primary); }
        .theme-ring-focus:focus { --tw-ring-color: var(--app-primary); }
        
        /* Card & UI Element Styles */
        .card-bg { background-color: var(--app-card-bg); }
        .card-hover:hover { background-color: var(--app-card-hover-bg); }
        .input-bg { background-color: var(--app-input-bg); }
        .progress-track-bg { background-color: var(--app-border); }

        /* Custom Checkbox Style */
        .custom-checkbox { position: relative; }
        .custom-checkbox .check-icon { opacity: 0; transition: opacity 0.2s ease; }
        .custom-checkbox.checked .check-icon { opacity: 1; }
        
        /* Modal specific transitions */
        .modal-active { visibility: visible; opacity: 1; pointer-events: auto; }
        .modal-inactive { visibility: hidden; opacity: 0; pointer-events: none; }
        .modal-card-active { transform: scale(1); opacity: 1; }
        .modal-card-inactive { transform: scale(0.95); opacity: 0; }

        /* Calendar Styling */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        /* Animation for notifications */
        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        .animate-fade-in-right {
            animation: fadeInRight 0.5s ease-out forwards;
        }

        /* Drag and drop styles */
        .task-card.dragging, .subtask-item.dragging {
            opacity: 0.5;
            border: 2px dashed var(--app-primary);
        }
        .drag-handle { cursor: grab; }
        .drag-handle:active { cursor: grabbing; }

        /* Note editor styles */
        .note-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            border-top: 1px solid transparent;
        }
        .note-section.open {
            max-height: 500px;
        }

    </style>
</head>
<body class="min-h-screen app-bg app-text">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        const useDebounce = (callback, delay) => {
            const timeoutRef = useRef(null);
            useEffect(() => {
                return () => clearTimeout(timeoutRef.current);
            }, []);
            return (...args) => {
                clearTimeout(timeoutRef.current);
                timeoutRef.current = setTimeout(() => {
                    callback(...args);
                }, delay);
            };
        };

        // --- ICONS ---
        const CalendarIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg> );
        const DownloadIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> );
        const UploadIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg> );
        const XIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg> );
        const MenuIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg> );
        const PlusIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> );
        const CheckIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="20 6 9 17 4 12"/></svg> );
        const EditIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg> );
        const TrashIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg> );
        const CompassIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/></svg> );
        const CheckCircleIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/></svg> );
        const XCircleIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg> );
        const InfoIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg> );
        const ChevronDownIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m6 9 6 6 6-6"/></svg> );
        const GripVerticalIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="9" cy="12" r="1"></circle><circle cx="9" cy="5" r="1"></circle><circle cx="9" cy="19" r="1"></circle><circle cx="15" cy="12" r="1"></circle><circle cx="15" cy="5" r="1"></circle><circle cx="15" cy="19" r="1"></circle></svg> );
        const NoteIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M13.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8.5L13.5 2z"></path><polyline points="14 2 14 9 21 9"></polyline></svg>);
        const BoldIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>);
        const UnderlineIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></svg>);
        const ListIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>);

        // --- COMPONENTS ---

        const Notification = ({ notification, onDismiss }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onDismiss(notification.id);
                }, 3000); // Set timeout to 3 seconds for better UX
                return () => clearTimeout(timer);
            }, [notification.id, onDismiss]);

            let icon;
            switch (notification.type) {
                case 'success': icon = <CheckCircleIcon className="w-5 h-5 text-green-400" />; break;
                case 'error': icon = <XCircleIcon className="w-5 h-5 text-red-400" />; break;
                case 'info': default: icon = <InfoIcon className="w-5 h-5 text-blue-400" />; break;
            }

            return (
                <div className="p-3 mb-2 rounded-xl shadow-xl border-2 border-gray-500/50 text-white flex items-start w-72 pointer-events-auto animate-fade-in-right bg-black/50 backdrop-blur-sm">
                    <div className="mr-3 flex-shrink-0">{icon}</div>
                    <div className="flex-grow text-sm">{notification.message}</div>
                </div>
            );
        };

        const NotificationArea = ({ notifications, onDismiss }) => (
            <div className="fixed top-0 right-0 p-4 z-[100] pointer-events-none">
                {notifications.map(notification => (
                    <Notification key={notification.id} notification={notification} onDismiss={onDismiss} />
                ))}
            </div>
        );

        const HistoryModal = ({ isOpen, onClose, historyData, onViewDay }) => {
            const getLocalTodayKey = () => new Date().toISOString().split('T')[0];
            const [currentDate, setCurrentDate] = useState(new Date());
            const [selectedDateKey, setSelectedDateKey] = useState(getLocalTodayKey());

            useEffect(() => { if (isOpen) { setCurrentDate(new Date()); setSelectedDateKey(getLocalTodayKey()); } }, [isOpen]);
            const changeMonth = (delta) => setCurrentDate(prev => { const newDate = new Date(prev); newDate.setMonth(newDate.getMonth() + delta); return newDate; });

            const renderCalendar = () => {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const todayKey = getLocalTodayKey();
                const days = Array(firstDayOfMonth).fill(null).map((_, i) => <div key={`empty-${i}`}></div>);
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const hasHistory = historyData[dateKey] && historyData[dateKey].length > 0;
                    days.push( <button key={dateKey} onClick={() => setSelectedDateKey(dateKey)} className={`relative p-2 rounded-lg text-sm transition duration-150 flex items-center justify-center flex-col card-hover ${dateKey === todayKey ? 'theme-border border-2' : ''} ${dateKey === selectedDateKey ? 'ring-2 ring-offset-2 ring-offset-slate-800 theme-ring-focus' : ''}`}> {day} {hasHistory && <span className="w-1.5 h-1.5 rounded-full absolute bottom-1.5 theme-bg"></span>} </button> );
                }
                return days;
            };

            const selectedHistoryCount = selectedDateKey ? (historyData[selectedDateKey] || []).length : 0;
            return ( <div className={`modal fixed inset-0 z-50 flex items-center justify-center bg-black/70 ${isOpen ? 'modal-active' : 'modal-inactive'}`} onClick={onClose}> <div className={`p-6 w-full max-w-lg rounded-2xl shadow-2xl transform transition duration-300 ${isOpen ? 'modal-card-active' : 'modal-card-inactive'} card-bg`} onClick={e => e.stopPropagation()}> <div className="flex justify-between items-center mb-4 border-b pb-3 app-border"> <h2 className="text-2xl font-bold theme-text">Task History</h2> <button onClick={onClose} className="p-1 rounded-full text-gray-300 transition" aria-label="Close history modal"><XIcon className="w-5 h-5" /></button> </div> <div className="flex justify-between items-center mb-4 text-center"> <button onClick={() => changeMonth(-1)} className="p-2 rounded-lg transition theme-text" aria-label="Previous month">&lt;</button> <h3 className="text-xl font-semibold">{currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}</h3> <button onClick={() => changeMonth(1)} className="p-2 rounded-lg transition theme-text" aria-label="Next month">&gt;</button> </div> <div className="calendar-grid text-center text-sm font-medium mb-2 text-gray-400"> <span>Sun</span><span>Mon</span><span>Tue</span><span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span> </div> <div className="calendar-grid">{renderCalendar()}</div> <div className="mt-6 pt-4 border-t app-border min-h-[80px]"> {selectedDateKey && ( <div className="flex justify-between items-center"> <div> <h4 className="text-xl font-semibold theme-text">{`Entries for ${selectedDateKey}`}</h4> <p className="text-sm text-gray-400">{selectedHistoryCount} task(s) logged on this day.</p> </div> <button onClick={() => onViewDay(selectedDateKey)} className="px-4 py-2 text-base font-semibold rounded-lg theme-bg text-white hover:opacity-90 transition shadow-md"> View Day &rarr; </button> </div> )} </div> </div> </div> );
        };

        const TaskModal = ({ isOpen, onClose, onSave, editingHistoryLog, dateKey, isAddingUnavoidable }) => {
            const [title, setTitle] = useState('');
            const [subtaskInput, setSubtaskInput] = useState('');
            const [subtasks, setSubtasks] = useState([]);
            const draggedSubtaskIndex = useRef(null);
            const [isDragging, setIsDragging] = useState(false);
            
            useEffect(() => { if (isOpen) { const currentItem = editingHistoryLog?.log; setTitle(currentItem?.title || ''); setSubtasks(currentItem ? JSON.parse(JSON.stringify(currentItem.subtasks)) : []); } else { setTitle(''); setSubtaskInput(''); setSubtasks([]); } }, [isOpen, editingHistoryLog]);

            const handleAddSubtask = () => { if (subtaskInput.trim()) { setSubtasks([...subtasks, { description: subtaskInput.trim(), completed: false }]); setSubtaskInput(''); } };
            const handleRemoveSubtask = (index) => setSubtasks(subtasks.filter((_, i) => i !== index));
            const handleSubtaskChange = (index, newDescription) => {
                const updatedSubtasks = [...subtasks];
                updatedSubtasks[index].description = newDescription;
                setSubtasks(updatedSubtasks);
            };
            const handleSubmit = (e) => { e.preventDefault(); if (!title.trim()) return; let finalSubtasks = [...subtasks]; if (subtaskInput.trim()) { finalSubtasks.push({ description: subtaskInput.trim(), completed: false }); } onSave({ id: editingHistoryLog?.log.id, title, subtasks: finalSubtasks }); };
            
            const handleSubtaskDragStart = (e, index) => { draggedSubtaskIndex.current = index; e.dataTransfer.effectAllowed = 'move'; setIsDragging(true); };
            const handleSubtaskDragOver = (e, index) => { e.preventDefault(); const draggedOverItem = index; if (draggedSubtaskIndex.current === draggedOverItem) return; const items = [...subtasks]; const [reorderedItem] = items.splice(draggedSubtaskIndex.current, 1); items.splice(draggedOverItem, 0, reorderedItem); draggedSubtaskIndex.current = draggedOverItem; setSubtasks(items); };
            const handleSubtaskDragEnd = () => { draggedSubtaskIndex.current = null; setIsDragging(false); };

            let modalTitle = isAddingUnavoidable ? (editingHistoryLog ? "Edit Unavoidable Task" : "Add Unavoidable Task") : (editingHistoryLog ? 'Edit Daily Task' : 'Add New Daily Task');
            return ( <div className={`modal fixed inset-0 z-50 flex items-center justify-center bg-black/70 ${isOpen ? 'modal-active' : 'modal-inactive'}`} onClick={onClose}> <div className={`p-6 w-full max-w-md rounded-2xl shadow-2xl transform transition duration-300 ${isOpen ? 'modal-card-active' : 'modal-card-inactive'} card-bg`} onClick={(e) => e.stopPropagation()}> <div className="flex justify-between items-center mb-4 border-b pb-3 app-border"> <h2 className="text-2xl font-bold theme-text">{modalTitle}</h2> <button onClick={onClose} className="p-1 rounded-full text-gray-300 transition" aria-label="Close modal"><XIcon className="w-5 h-5" /></button> </div> <form onSubmit={handleSubmit}> <div className="mb-4"> <label htmlFor="taskTitle" className="block text-sm font-medium mb-1">Task Title <span className="text-red-500">*</span></label> <input id="taskTitle" type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Complete Morning Run" className="w-full p-3 rounded-lg border theme-ring-focus focus:ring-2 transition-colors duration-200 input-bg app-border app-text" required /> </div> <div className="mb-4"> <label className="block text-sm font-medium mb-2">Subtasks</label> <div className="flex space-x-2"> <input id="subtaskInput" type="text" value={subtaskInput} onChange={(e) => setSubtaskInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddSubtask())} placeholder="Add a new subtask..." className="flex-grow p-3 rounded-lg border theme-ring-focus focus:ring-2 transition-colors duration-200 input-bg app-border app-text" /> <button type="button" onClick={handleAddSubtask} className="p-3 theme-bg text-white rounded-lg hover:opacity-90 transition-colors duration-200 flex items-center justify-center" aria-label="Add subtask"><PlusIcon className="w-5 h-5" /></button> </div> </div> {subtasks.length > 0 && ( <div className="mb-4 max-h-40 overflow-y-auto pr-2 space-y-2"> {subtasks.map((st, index) => ( <div key={index} draggable onDragStart={(e) => handleSubtaskDragStart(e, index)} onDragOver={(e) => handleSubtaskDragOver(e, index)} onDragEnd={handleSubtaskDragEnd} className={`subtask-item flex items-center p-2 rounded-lg card-hover transition-all duration-200 ${isDragging && draggedSubtaskIndex.current === index ? 'dragging' : ''}`}> <div className="drag-handle text-gray-500 mr-2"><GripVerticalIcon className="w-5 h-5" /></div> <input type="text" value={st.description} onChange={(e) => handleSubtaskChange(index, e.target.value)} className="flex-grow bg-transparent border-0 focus:ring-0 text-sm" /> <button type="button" onClick={() => handleRemoveSubtask(index)} className="text-red-400 hover:text-red-500 p-1 rounded-full hover:bg-red-900/10 transition" aria-label="Remove subtask"><XIcon className="w-4 h-4" /></button> </div> ))} </div> )} <button type="submit" className="w-full py-3 mt-4 font-semibold rounded-xl transition duration-300 theme-bg hover:opacity-90 text-white shadow-lg">{editingHistoryLog ? 'Update Task' : 'Save Task'}</button> <p className="text-xs text-center text-gray-400 mt-2">Applying changes for: <span className="font-bold">{dateKey}</span></p> </form> </div> </div> );
        };
        
        const BottomNav = ({ onOpenMenu, onOpenTaskModal }) => (
            <div className="fixed bottom-0 left-0 right-0 z-30 flex justify-between p-4 pointer-events-none">
                <button onClick={onOpenMenu} className="w-14 h-14 rounded-full pointer-events-auto shadow-2xl flex items-center justify-center transform hover:scale-110 transition duration-300 focus:outline-none theme-bg text-white" aria-label="Open menu"><MenuIcon className="w-6 h-6" /></button>
                <button onClick={onOpenTaskModal} className="w-14 h-14 rounded-full pointer-events-auto shadow-2xl flex items-center justify-center transform hover:scale-110 transition duration-300 focus:outline-none theme-bg text-white" aria-label="Add new task"><PlusIcon className="w-[30px] h-[30px]" /></button>
            </div>
        );

        const lightenColor = (hex, percent) => { if (!hex || hex.length < 7) return '#cccccc'; try { let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); const p = percent / 100; r = Math.round(Math.min(255, r + (255 - r) * p)); g = Math.round(Math.min(255, g + (255 - g) * p)); b = Math.round(Math.min(255, b + (255 - b) * p)); return "#" + (r).toString(16).padStart(2, '0') + (g).toString(16).padStart(2, '0') + (b).toString(16).padStart(2, '0'); } catch(e) { return '#cccccc'; } };

        const TaskItem = ({ task, onToggle, onEdit, onDelete, dragProps }) => {
            const [isDragging, setIsDragging] = useState(false);
            const isCompleted = task.subtasks.length > 0 ? task.subtasks.every(st => st.completed) : !!task.completed;
            const taskColor = task.color || '#6366f1';
            const subtaskColor = task.color ? lightenColor(task.color, 40) : '#10b981';

            return ( <div draggable onDragStart={(e) => { setIsDragging(true); dragProps.onDragStart(e, { index: dragProps.index, isUnavoidable: task.isUnavoidable }); }} onDragEnter={(e) => dragProps.onDragEnter(e, dragProps.index)} onDragEnd={() => setIsDragging(false)} onDragOver={(e) => e.preventDefault()} onDrop={dragProps.onDrop} className={`task-card p-4 mb-4 rounded-xl shadow-lg transition-all duration-300 card-bg card-hover ${isCompleted ? 'opacity-70' : ''} ${isDragging ? 'dragging' : ''}`} > <div className="flex items-start mb-2 group"> <button onClick={() => onToggle(task.id)} className={`flex-shrink-0 mr-3 mt-1 rounded-lg w-6 h-6 border-2 flex items-center justify-center transition duration-200 custom-checkbox ${isCompleted ? 'checked' : ''}`} style={{ borderColor: taskColor, backgroundColor: isCompleted ? taskColor : 'transparent' }} aria-label={`Mark task as ${isCompleted ? 'incomplete' : 'complete'}`}> <CheckIcon className="check-icon text-white w-4 h-4" strokeWidth={3} /> </button> <h3 className={`font-extrabold text-xl flex-grow ${isCompleted && task.subtasks.length === 0 ? 'line-through' : ''}`} style={{ color: taskColor }}>{task.title}</h3> <button onClick={() => onEdit(task.id)} className="text-gray-400 p-1 rounded-full opacity-50 group-hover:opacity-100 transition duration-300 hover:text-yellow-500 ml-auto" aria-label="Edit Task"><EditIcon className="w-[18px] h-[18px]" /></button> <button onClick={() => onDelete(task.id)} className="text-gray-400 p-1 rounded-full opacity-50 group-hover:opacity-100 transition duration-300 hover:text-red-500 ml-1" aria-label="Delete Task"><TrashIcon className="w-[18px] h-[18px]" /></button> </div> {task.subtasks.length > 0 && ( <ul className="pt-2 pl-2 border-l border-dashed app-border space-y-2 mt-2"> {task.subtasks.map((subtask, index) => ( <li key={index} className="flex items-center text-sm text-gray-300 group"> <button onClick={() => onToggle(task.id, index)} className={`flex-shrink-0 mr-3 rounded-md w-5 h-5 border-2 flex items-center justify-center transition duration-200 custom-checkbox ${subtask.completed ? 'checked' : ''}`} style={{ borderColor: subtaskColor, backgroundColor: subtask.completed ? subtaskColor : 'transparent' }} aria-label={`Mark subtask as ${subtask.completed ? 'incomplete' : 'complete'}`}> <CheckIcon className="check-icon text-white w-3 h-3" strokeWidth={3} /> </button> <span className={`flex-grow transition duration-200 ${subtask.completed ? 'line-through opacity-60' : ''}`}>{subtask.description}</span> </li> ))} </ul> )} </div> );
        };

        const DailyNoteSection = ({ note, onUpdateNote }) => {
            const [isOpen, setIsOpen] = useState(true);
            const [localNote, setLocalNote] = useState(note || '');

            useEffect(() => {
                setLocalNote(note || '');
            }, [note]);

            const debouncedNoteUpdate = useDebounce((newNote) => onUpdateNote(newNote), 500);

            const handleNoteChange = (e) => {
                const newValue = e.target.value;
                setLocalNote(newValue);
                debouncedNoteUpdate(newValue);
            };

            return (
                <div className="mt-8">
                    <div className="mb-6 app-border border-b-2 pb-4">
                        <div className="flex justify-between items-center cursor-pointer" onClick={() => setIsOpen(!isOpen)}>
                            <h2 className="text-lg font-bold theme-text flex items-center">
                                <NoteIcon className="w-5 h-5 mr-2"/>Daily Notes
                            </h2>
                            <ChevronDownIcon className={`w-6 h-6 theme-text transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`} />
                        </div>
                        <div className={`note-section ${isOpen ? 'open' : ''}`} style={{borderTop: 'none', paddingTop: isOpen ? '1rem' : '0'}}>
                            <textarea
                                value={localNote}
                                onChange={handleNoteChange}
                                placeholder="Add your notes for the day here..."
                                className="input-bg app-border p-3 border rounded-lg w-full focus:ring-2 theme-ring-focus transition-colors duration-200"
                                style={{ minHeight: '120px', resize: 'vertical', outline: 'none' }}
                            />
                        </div>
                    </div>
                </div>
            );
        };


        const TaskList = (props) => {
            const { dailyTasks, dateKey, isUnavoidableOpen, onToggleUnavoidable, onAddTask, onToggleTask, onEditTask, onDeleteTask, onReorderTasks, dailyNote, onUpdateDailyNote } = props;
            const dragItemData = useRef(null);

            const handleDragStart = (e, data) => { dragItemData.current = data; e.dataTransfer.effectAllowed = 'move'; };
            const handleDrop = (e, targetIndex) => { const draggedItem = dragItemData.current; const targetTask = dailyTasks[targetIndex]; if (draggedItem && draggedItem.isUnavoidable === targetTask.isUnavoidable) { onReorderTasks(dateKey, draggedItem.index, targetIndex); } dragItemData.current = null; };
            
            const unavoidableTasks = dailyTasks.filter(task => task.isUnavoidable);
            const regularTasks = dailyTasks.filter(task => !task.isUnavoidable);

            const renderTask = (task) => {
                const globalIndex = dailyTasks.findIndex(t => t.id === task.id);
                const dragProps = { index: globalIndex, onDragStart: handleDragStart, onDragEnter: () => {}, onDrop: (e) => handleDrop(e, globalIndex) };
                return <TaskItem key={task.id} task={task} onToggle={(id, subIdx) => onToggleTask(dateKey, id, subIdx)} onEdit={() => onEditTask(dateKey, task)} onDelete={(id) => onDeleteTask(dateKey, id)} dragProps={dragProps} />;
            };
            
            return ( <div className="max-w-3xl mx-auto mt-8"> <div className="mb-6 app-border border-b-2 pb-4"> <div className="flex justify-between items-center cursor-pointer" onClick={onToggleUnavoidable}> <h2 className="text-lg font-bold theme-text">Unavoidable Tasks</h2> <div className="flex items-center space-x-2"> <button onClick={(e) => { e.stopPropagation(); onAddTask(true); }} className="p-1 rounded-full theme-bg text-white hover:opacity-80 transition" aria-label="Add Unavoidable Task"><PlusIcon className="w-5 h-5" /></button> <ChevronDownIcon className={`w-6 h-6 theme-text transition-transform duration-300 ${isUnavoidableOpen ? 'rotate-180' : ''}`} /> </div> </div> {isUnavoidableOpen && ( <div className="mt-4"> {unavoidableTasks.length > 0 ? unavoidableTasks.map(renderTask) : <p className="text-sm text-gray-400">No unavoidable tasks added for this day.</p>} </div> )} </div> <h2 className="text-lg font-bold theme-text mb-4">Daily Tasks</h2> {regularTasks.length === 0 && unavoidableTasks.length === 0 ? ( <div className={`text-center py-16 px-4 rounded-xl border-4 border-dashed app-border text-gray-400`}> <CompassIcon className="mx-auto mb-4 theme-text w-9 h-9" /> <p className="text-xl font-semibold">Start your Journey!</p> <p>Click the '+' button to add your first daily Task.</p> </div> ) : ( regularTasks.map(renderTask) )} <DailyNoteSection note={dailyNote} onUpdateNote={onUpdateDailyNote} /> </div> );
        };

        const Header = ({ tasks, viewingDate, customTheme }) => {
            const formatDate = (dateString) => { const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; const date = dateString ? new Date(dateString.replace(/-/g, '/')) : new Date(); return date.toLocaleString(undefined, options); };
            const { completedItems, totalItems, percentage } = useMemo(() => { let total = 0, completed = 0; tasks.forEach(task => { if (task.subtasks.length > 0) { total += task.subtasks.length; completed += task.subtasks.filter(st => st.completed).length; } else { total += 1; if (task.completed) completed += 1; } }); return { completedItems: completed, totalItems: total, percentage: total > 0 ? (completed / total) * 100 : 0 }; }, [tasks]);
            const trackColor = useMemo(() => lightenColor(customTheme.primary, 80), [customTheme.primary]);
            return ( <header className="flex flex-col items-center py-4 relative"> <h1 className="text-6xl font-extrabold tracking-tight cursive-title mb-2">The Journey</h1> <p className="text-lg font-medium mb-4 text-gray-400">{formatDate(viewingDate)}</p> <div className="w-full max-w-3xl mt-4 rounded-full h-3" style={{ backgroundColor: trackColor }}> <div className="progress-bar h-3 rounded-full theme-bg" style={{ width: `${percentage}%` }}></div> </div> <p className="text-sm mt-1 text-gray-400">{completedItems} of {totalItems} steps complete ({percentage.toFixed(0)}%)</p> </header> );
        };

        const ColorInput = ({ label, value, onChange }) => ( <div className="flex items-center justify-between"> <label className="text-sm font-medium">{label}</label> <input type="color" value={value} onChange={onChange} className="w-8 h-8 p-0 border-none rounded cursor-pointer bg-transparent" /> </div> );

        const Sidebar = ({ isOpen, onClose, customTheme, onThemeChange, onThemeReset, onOpenHistory, onExport, onImportClick }) => { const handleColorChange = (key, value) => onThemeChange({ ...customTheme, [key]: value }); return ( <div className={`sidebar card-bg fixed top-0 left-0 h-full w-64 z-40 shadow-2xl p-6 transition-transform duration-300 transform ${isOpen ? 'translate-x-0' : '-translate-x-full'} app-border border-r`}> <div className="flex justify-between items-center mb-8 app-border border-b pb-4"> <h1 className="text-3xl font-bold theme-text">Settings</h1> <button onClick={onClose} className="p-2 rounded-full transition theme-text" aria-label="Close menu"><XIcon className="w-6 h-6" /></button> </div> <div className="space-y-6"> <button onClick={onOpenHistory} className="w-full flex items-center justify-center p-3 rounded-xl transition-colors duration-200 theme-text theme-border/50 border card-hover"><CalendarIcon className="mr-2 w-5 h-5" />Task History</button> <div className="space-y-3 pt-4 app-border border-t"> <p className="text-sm font-semibold theme-text border-b app-border/30 pb-2">Local Data Backup</p> <button onClick={onExport} className="w-full flex items-center justify-center p-3 rounded-xl transition-colors duration-200 theme-bg hover:opacity-90 text-white shadow-md"><DownloadIcon className="mr-2 w-5 h-5" />Export Data (JSON)</button> <button onClick={onImportClick} className="w-full flex items-center justify-center p-3 rounded-xl transition-colors duration-200 theme-text theme-border/50 border card-hover"><UploadIcon className="mr-2 w-5 h-5" />Import Data (JSON)</button> </div> <div className="space-y-3 pt-4 app-border border-t"> <p className="text-sm font-semibold theme-text border-b app-border/30 pb-2">Theme Customization</p> <ColorInput label="Background" value={customTheme.background} onChange={(e) => handleColorChange('background', e.target.value)} /> <ColorInput label="Card" value={customTheme.card} onChange={(e) => handleColorChange('card', e.target.value)} /> <ColorInput label="Text" value={customTheme.text} onChange={(e) => handleColorChange('text', e.target.value)} /> <ColorInput label="Primary" value={customTheme.primary} onChange={(e) => handleColorChange('primary', e.target.value)} /> <button onClick={onThemeReset} className="w-full text-xs p-2 mt-2 rounded-lg theme-border border hover:opacity-80 transition">Reset to Default Theme</button> </div> </div> </div> ); };
        
        // --- MAIN APP ---
        const App = () => {
            const HISTORY_KEY = 'journey_history_v2';
            const NOTES_KEY = 'journey_notes_v1';
            const THEME_KEY = 'journey_custom_theme';
            const COLOR_PALETTE = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#ec4899'];
            const DEFAULT_THEME = { background: '#0f172a', text: '#f1f5f9', primary: '#6366f1', card: '#1e293b', cardHover: '#334155', border: '#334155', input: '#0f172a' };
            const generateId = () => `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

            const [taskHistory, setTaskHistory] = useState({});
            const [dailyNotes, setDailyNotes] = useState({});
            const [customTheme, setCustomTheme] = useState(DEFAULT_THEME);
            const [isSidebarOpen, setSidebarOpen] = useState(false);
            const [isTaskModalOpen, setTaskModalOpen] = useState(false);
            const [isHistoryModalOpen, setHistoryModalOpen] = useState(false);
            const [editingHistoryLog, setEditingHistoryLog] = useState(null);
            const [isAddingUnavoidable, setIsAddingUnavoidable] = useState(false);
            const [viewingDate, setViewingDate] = useState(null);
            const [isUnavoidableOpen, setIsUnavoidableOpen] = useState(true);
            const [notifications, setNotifications] = useState([]);
            const notificationCounter = useRef(0);
            const fileInputRef = useRef(null);

            const audioInitialized = useRef(false);
            const synth = useRef(null);
            const polySynth = useRef(null);

            const initAudio = () => { if (audioInitialized.current || typeof Tone === 'undefined') return; try { if (Tone.context.state !== 'running') Tone.start(); synth.current = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); polySynth.current = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.05, release: 0.5 } }).toDestination(); audioInitialized.current = true; } catch (e) { console.error("Audio initialization failed:", e); } };
            const playTock = useCallback(() => { if (audioInitialized.current && synth.current) synth.current.triggerAttackRelease("C5", "8n"); }, []);
            const playChime = useCallback(() => { if (audioInitialized.current && polySynth.current) polySynth.current.triggerAttackRelease(["E5", "G5", "C6"], "4n"); }, []);
            const playWhoosh = useCallback(() => { if (audioInitialized.current && polySynth.current) polySynth.current.triggerAttackRelease(["C3", "C2"], "8n"); }, []);
            
            const getTodayKey = useCallback(() => new Date().toISOString().split('T')[0], []);
            const showNotification = useCallback((message, type) => { notificationCounter.current++; const newNotification = { id: notificationCounter.current, message, type }; setNotifications(prev => [...prev, newNotification]); }, []);
            const saveHistoryToStorage = useCallback((updatedHistory) => { try { localStorage.setItem(HISTORY_KEY, JSON.stringify(updatedHistory)); } catch (error) { showNotification('Error saving task history.', 'error'); } }, [showNotification]);
            const saveNotesToStorage = useCallback((updatedNotes) => { try { localStorage.setItem(NOTES_KEY, JSON.stringify(updatedNotes)); } catch (error) { showNotification('Error saving daily notes.', 'error'); } }, [showNotification]);

            useEffect(() => {
                let loadedHistory = {}; let loadedNotes = {};
                try { 
                    const storedHistory = localStorage.getItem(HISTORY_KEY); loadedHistory = storedHistory ? JSON.parse(storedHistory) : {}; 
                    const storedNotes = localStorage.getItem(NOTES_KEY); loadedNotes = storedNotes ? JSON.parse(storedNotes) : {};
                } catch (error) { showNotification('Error loading stored data.', 'error'); }
                
                let historyUpdated = false; let notesMigrated = false;
                Object.keys(loadedHistory).forEach(dateKey => {
                    let dailyNoteContent = [];
                    (loadedHistory[dateKey] || []).forEach(task => {
                        if (task.note) {
                            dailyNoteContent.push(`<strong>From task "${task.title}":</strong><br>${task.note}`);
                            delete task.note; historyUpdated = true; notesMigrated = true;
                        }
                    });
                    if (dailyNoteContent.length > 0) {
                        loadedNotes[dateKey] = (loadedNotes[dateKey] || '') + dailyNoteContent.join('<hr style="margin: 8px 0; border-color: var(--app-border);">');
                    }
                });
                if (historyUpdated) { saveHistoryToStorage(loadedHistory); }
                if (notesMigrated) { saveNotesToStorage(loadedNotes); showNotification('Notes have been moved to a new daily section!', 'info'); }

                let notesSimplified = false;
                const convertHtmlToText = (html) => {
                    if (!html) return '';
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    tempDiv.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
                    tempDiv.querySelectorAll('p, div, li').forEach(el => {
                        if (el.tagName === 'LI' && !el.textContent.trim().startsWith('•')) {
                            el.prepend('• ');
                        }
                        el.append('\n');
                    });
                    let text = tempDiv.textContent || tempDiv.innerText;
                    return text.replace(/[ \t]+/g, ' ').replace(/\n\s*\n+/g, '\n').trim();
                };

                Object.keys(loadedNotes).forEach(dateKey => {
                    const note = loadedNotes[dateKey];
                    if (note && /<[a-z][\s\S]*>/i.test(note)) {
                        loadedNotes[dateKey] = convertHtmlToText(note);
                        notesSimplified = true;
                    }
                });

                if (notesSimplified) {
                    saveNotesToStorage(loadedNotes);
                    showNotification('Daily notes have been simplified to plain text.', 'info');
                }

                const todayKey = getTodayKey();
                if (!loadedHistory[todayKey]) {
                    const mostRecentDateKey = Object.keys(loadedHistory).sort().reverse()[0];
                    if (mostRecentDateKey) {
                        const tasksToCarryOver = (loadedHistory[mostRecentDateKey] || []).filter(task => !task.isUnavoidable);
                        loadedHistory[todayKey] = tasksToCarryOver.map(task => ({ ...task, id: generateId(), completed: false, subtasks: task.subtasks.map(st => ({ ...st, completed: false })), completedAt: new Date().toISOString() }));
                    } else { loadedHistory[todayKey] = []; }
                }
                setTaskHistory(loadedHistory);
                setDailyNotes(loadedNotes);
                saveHistoryToStorage(loadedHistory);
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme) { setCustomTheme(JSON.parse(savedTheme)); }
            }, []);

            useEffect(() => {
                const root = document.documentElement;
                root.style.setProperty('--app-bg', customTheme.background);
                root.style.setProperty('--app-text', customTheme.text);
                root.style.setProperty('--app-primary', customTheme.primary);
                root.style.setProperty('--app-card-bg', customTheme.card);
                root.style.setProperty('--app-card-hover-bg', customTheme.cardHover);
                root.style.setProperty('--app-border', customTheme.border);
                root.style.setProperty('--app-input-bg', customTheme.input);
                localStorage.setItem(THEME_KEY, JSON.stringify(customTheme));
            }, [customTheme]);
            
            const resetTheme = () => setCustomTheme(DEFAULT_THEME);

            const handleSaveTask = (taskData) => {
                const dateKey = viewingDate || getTodayKey();
                setTaskHistory(prev => {
                    const newHistory = { ...prev };
                    const dateHistory = newHistory[dateKey] ? [...newHistory[dateKey]] : [];
                    if (taskData.id) { // Update
                        const index = dateHistory.findIndex(t => t.id === taskData.id);
                        if (index !== -1) { dateHistory[index] = { ...dateHistory[index], title: taskData.title, subtasks: taskData.subtasks, completed: taskData.subtasks.length > 0 ? taskData.subtasks.every(st => st.completed) : dateHistory[index].completed }; }
                    } else { // Add
                        const newLog = { id: generateId(), title: taskData.title, subtasks: taskData.subtasks, completedAt: new Date(dateKey.replace(/-/g, '/')).toISOString(), color: COLOR_PALETTE[Object.values(prev).flat().length % COLOR_PALETTE.length], completed: false, isUnavoidable: isAddingUnavoidable };
                        dateHistory.push(newLog);
                        playChime();
                    }
                    newHistory[dateKey] = dateHistory;
                    saveHistoryToStorage(newHistory);
                    return newHistory;
                });
                closeTaskModal();
            };

            const handleToggleTask = (dateKey, logId, subtaskIndex) => {
                setTaskHistory(prev => {
                    const newHistory = { ...prev };
                    newHistory[dateKey] = (newHistory[dateKey] || []).map(log => {
                        if (log.id === logId) {
                            const updatedLog = { ...log, subtasks: JSON.parse(JSON.stringify(log.subtasks)) };
                            if (subtaskIndex !== undefined) { updatedLog.subtasks[subtaskIndex].completed = !updatedLog.subtasks[subtaskIndex].completed; updatedLog.completed = updatedLog.subtasks.every(st => st.completed); } else if (updatedLog.subtasks.length === 0) { updatedLog.completed = !updatedLog.completed; } else { const targetCompletion = !updatedLog.completed; updatedLog.subtasks = updatedLog.subtasks.map(st => ({ ...st, completed: targetCompletion })); updatedLog.completed = targetCompletion; }
                            if (updatedLog.completed) playChime(); else playTock();
                            return updatedLog;
                        }
                        return log;
                    });
                    saveHistoryToStorage(newHistory);
                    return newHistory;
                });
            };

            const handleDeleteTask = (dateKey, logId) => { setTaskHistory(prev => { const newHistory = { ...prev, [dateKey]: (prev[dateKey] || []).filter(t => t.id !== logId) }; saveHistoryToStorage(newHistory); playWhoosh(); return newHistory; }); };
            
            const handleUpdateDailyNote = (dateKey, note) => {
                setDailyNotes(prev => {
                    const newNotes = { ...prev, [dateKey]: note };
                    saveNotesToStorage(newNotes);
                    return newNotes;
                });
            };

            const handleReorderTasks = (dateKey, fromIndex, toIndex) => {
                setTaskHistory(prev => {
                    const newHistory = { ...prev };
                    const dateTasks = [...(newHistory[dateKey] || [])];
                    const [movedItem] = dateTasks.splice(fromIndex, 1);
                    dateTasks.splice(toIndex, 0, movedItem);
                    newHistory[dateKey] = dateTasks;
                    saveHistoryToStorage(newHistory);
                    return newHistory;
                });
            };

            const openTaskModalToAdd = (isUnavoidable) => { setIsAddingUnavoidable(isUnavoidable); setEditingHistoryLog(null); setTaskModalOpen(true); };
            const openTaskModalToEdit = (dateKey, log) => { setEditingHistoryLog({dateKey, log}); setIsAddingUnavoidable(!!log.isUnavoidable); setTaskModalOpen(true); };
            const closeTaskModal = () => { setTaskModalOpen(false); setEditingHistoryLog(null); setIsAddingUnavoidable(false); };
            
            const goToToday = () => setViewingDate(null);
            const viewDay = (dateKey) => { setViewingDate(dateKey === getTodayKey() ? null : dateKey); setHistoryModalOpen(false); };

            const exportData = () => { const data = JSON.stringify({ history: taskHistory, notes: dailyNotes, customTheme }, null, 2); const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([data], { type: 'application/json' })); a.download = `the_journey_backup_${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(a.href); };
            const importData = (event) => { const file = event.target.files?.[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const importedData = JSON.parse(e.target?.result); if (!importedData.history) throw new Error("Invalid file format."); setTaskHistory(importedData.history); if (importedData.notes) setDailyNotes(importedData.notes); if (importedData.customTheme) setCustomTheme(importedData.customTheme); saveHistoryToStorage(importedData.history); if(importedData.notes) saveNotesToStorage(importedData.notes); showNotification('Data imported successfully!', 'success'); setSidebarOpen(false); } catch (error) { showNotification(`Import failed: ${error.message || 'File is corrupted.'}`, 'error'); } finally { if (event.target) event.target.value = ''; } }; reader.readAsText(file); };
            
            const currentDayKey = viewingDate || getTodayKey();
            const tasksForView = useMemo(() => taskHistory[currentDayKey] || [], [taskHistory, currentDayKey]);
            const noteForView = useMemo(() => dailyNotes[currentDayKey] || '', [dailyNotes, currentDayKey]);

            return (
                <React.Fragment>
                    {isSidebarOpen && <div className="fixed inset-0 bg-black/50 z-30" onClick={() => setSidebarOpen(false)} aria-hidden="true"></div>}
                    <Sidebar isOpen={isSidebarOpen} onClose={() => setSidebarOpen(false)} customTheme={customTheme} onThemeChange={setCustomTheme} onThemeReset={resetTheme} onOpenHistory={() => { setHistoryModalOpen(true); setSidebarOpen(false); }} onExport={exportData} onImportClick={() => fileInputRef.current?.click()} />
                    <input type="file" ref={fileInputRef} accept=".json" className="hidden" onChange={importData} />
                    <div className="flex-grow p-4 md:p-8 pt-2 overflow-y-auto pb-24">
                        <Header tasks={tasksForView} viewingDate={viewingDate} customTheme={customTheme} />
                        <TaskList dailyTasks={tasksForView} dateKey={currentDayKey} isUnavoidableOpen={isUnavoidableOpen} onToggleUnavoidable={() => setIsUnavoidableOpen(prev => !prev)} onAddTask={openTaskModalToAdd} onToggleTask={handleToggleTask} onEditTask={openTaskModalToEdit} onDeleteTask={handleDeleteTask} onReorderTasks={handleReorderTasks} dailyNote={noteForView} onUpdateDailyNote={(newNote) => handleUpdateDailyNote(currentDayKey, newNote)} />
                    </div>
                    {viewingDate && (
                        <div className="fixed bottom-0 left-1/2 -translate-x-1/2 mb-4 z-30">
                            <button onClick={goToToday} className="px-6 py-3 text-base font-semibold rounded-full theme-bg text-white hover:opacity-90 transition shadow-lg flex items-center">&larr; Return to Today</button>
                        </div>
                    )}
                    <BottomNav onOpenMenu={() => { setSidebarOpen(true); initAudio(); }} onOpenTaskModal={() => openTaskModalToAdd(false)} />
                    <TaskModal isOpen={isTaskModalOpen} onClose={closeTaskModal} onSave={handleSaveTask} editingHistoryLog={editingHistoryLog} dateKey={currentDayKey} isAddingUnavoidable={isAddingUnavoidable} />
                    <HistoryModal isOpen={isHistoryModalOpen} onClose={() => setHistoryModalOpen(false)} historyData={taskHistory} onViewDay={viewDay} />
                    <NotificationArea notifications={notifications} onDismiss={(id) => setNotifications(n => n.filter(notif => notif.id !== id))} />
                </React.Fragment>
            );
        };

        // --- RENDER APP ---
        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(<App />);
        }
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
